#!/usr/bin/env bash
set -ue



# fun: print-usage
# txt: print acbuild-template usage info
function print-usage() {
	cat <<EOF
acbuild-template, make acbuild-scripts more declarative

Usage:	
  acbuild-template [-i|--script <script>] \
    [apply [-o|--output <output>]] \
    [build [-o|--output <output>] [-s|--silent|-n|--print-name-only] \
    [sign  [-o|--output <output>] [-s|--silent|-n|--print-name-only] [-p|--keyring <keyring> -k|--secret-keyring <secret keyring>]] \
    [install [-s|--silent|-n|--print-hash-only]] \
    [run <rkt image run parameters>]

Options:
  -h --help                print this message
  -n --print-name          print nothing except resulting image full name
  -n --print-hash          print nothing except installed image hash
  -i --script              input script template to process, default ./acbuild-script
  -o --output              if building, resulting image, if not harcoded in script
                           if signing, resulting signature, by default image with suffix '.asc'
  -p --keyring             gpg keyring for signing
  -k --secret-keyring      gpg secret keyring for signing
  -s --silent              print nothing in case of success
  -n --print-file          like --silent, but print output filename
  -n --print-hash          print nothing except installed image hash

Environment:

  ACBUILD_SCRIPT           script to process (./acbuild-script by default)
  ACBUILD_IMAGE_DIR_NAME   directory to save resulting image
  ACBUILD_IMAGE_MODE       build mode, appc or oci
  ACBUILD_IMAGE_VERSION    label add os version (snapshot by default)
  ACBUILD_IMAGE_OS         label add os value (current by default)
  ACBUILD_IMAGE_ARCH       label add os value (current by arch)
  ACBUILD_IMAGE_EXT        image file extension, default aci  
  ACBUILD_RUN_INSECURE     run --insecure=value, defaul false
  ACBUILD_RUN_ENGINE       run --engine=value
  ACBUILD_IMAGE_BASE_NAME  image base file name, default {{name}}-{{version}}-{{os}}-{{arch}}.{{ext}}
  ACBUILD_IMAGE            image file full name
  ACBUILD_CACHE_DIR        directory to store temporary files
  
  ACBUILD_IMAGE_SIGNATURE  

  GPG                      gpg command, default gpg itself
  GPG_KEYRING
  GPG_SECURE_KEYRING

  ACBUILD                  acbuild command, default acbuild itself
  ACBUILD_OPTS

  RKT                      rkt command, default rkt itself
  RKT_OPTS
  RKT_FETCH_OPTS
  RKT_RUN_OPTS

EOF
}

# notes:
# acbuild-template upload bitbucket <username> <repo>
# acbuild-template upload github    <username> <repo>
# todo curl -u {{username}} -X POST https://api.bitbucket.org/2.0/repositories/{{username}}/{{repo}}/downloads -F files=@{filename}


# fun: check-non-empty-arguments [ arg1 [ arg2 [...] ] ]
# txt: return 0 if empty arguments, otherwise 1
function check-non-empty-arguments() {
	if [[ -z "${1+x}" ]]; then
		echo "debug: arguments are $@"
		echo 'arguments expected, see acbuild-scripter help'
		print-usage
		return 1
	fi
}


# fun: errcho msg1 msg2 msg3 ..
# txt: print arguments to stderr
function errcho() {
	[[ -n "$@" ]] && >&2 echo "$@" || true
}


function errxit() {
	errcho "$@"
	exit 1
}





# fun: value arg
# txt: if arg is nonempty print it, otherwise return error
function arg-value() {
	[[ -n "${1:-}" ]] && echo -n "$1" || return 1
}


# fun: echo <MULTILINE> | last-line
# txt: built-in equivalent of 'tail -n 1'
function last-line() {
	local value=$(recho)
	echo -n "${value##*$'\n'}"
}


necho() {
	echo -nE "$@"
}

# fun: copy stdin to stdout
# txt: 'echo hello | recho' does not work, use 'echo hello | echo $(recho)'
recho() {
	# option 1
	#necho "$(< /dev/stdin)"

	# option 2
	cat

	# option 3
	#local value=
	#read -d '' value
	#echo "$value"
}


# fun: cat value | stream-value
# txt: if stdin is nonempty print it, otherwise return error
stream-value() {
	arg-value "$(recho)"
}


function parse-mode() {
	sed -ne 's/^\s*begin\s.*--build-mode=\([^{} ]*\)\(\s.*\)\?$/\1/gp' | last-line | stream-value
}


# fun: cat acbuild-script | parse-name
# txt: parse acbuld-script and get image name (value ignored if contains placeholders)
function parse-name() {
	sed -ne 's/^\s*set-name\s\+\([^{} ]*\?\)\s*$/\1/gp' | last-line | stream-value
}


# fun: cat acbuild-script | parse-label <LABEL>
# txt: parse acbuld-script and get label value (value ignored if contains placeholders)
function parse-label() {
	sed -ne "s/^\s*label\s\+add\s\+$1\s\+\([^{} ]*\?\)\s*$/\1/gp" | last-line | stream-value
}


# fun: cat acbuild-script |   parse-oputout
# txt: parse acbuld-script and get image version (value ignored if contains placeholders)
function parse-output() {
	#sed -ne 's/^\s*write\s\+\(--overwrite\s\+\)\?\([^{} ]*\?\)\s*$/\2/gp' | last-line | stream-value
	sed -ne 's/^\s*write\s\+\(--overwrite\s\+\)\?["'\'']\?\([^{}"'\'' ]*\?\)["'\'']\?\s*$/\2/gp' | last-line | stream-value
}

# env: cache_dir: global variable to lazy store
function get-cache-dir() {
	echo "${cache_dir:-${ACBUILD_CACHE_DIR:-$(${MKTEMP:-mktemp} -d)}}"
}

#
function get-script() {
	arg-value "${1:-}" || arg-value "${ACBUILD_SCRIPT:-}" || necho 'acbuild-script'
}


# env: cache_dir
function get-dir-name() {
	arg-value "${ACBUILD_IMAGE_DIR_NAME:-}" || necho "$cache_dir"
}


# fun: mode-to-ext <MODE>
# txt: appc->aci, oci->oci
function mode-to-ext() {
	if   [[ appc == "${1:-}" ]]; then
		echo aci
	elif [[ oci == "${1:-}" ]]; then
		echo oci
	else
		return 1
	fi
}

# fun ext-to-mode <EXT>
# txt: aci->appc, oci->oci
function ext-to-mode() {
	if   [[ aci == "${1:-}" ]]; then
		echo appc
	elif [[ oci == "${1:-}" ]]; then
		echo oci
	else
		return 1
	fi
}

function get-mode() {
	parse-mode || arg-value "${ACBUILD_IMAGE_MODE:-}" || ext-to-mode "${ext:-}" || necho appc
}


# fun: get-name
# txt: 
# env: script: acbuild-script or template which must exist
#      name:   name if already known
function get-name() {
	parse-name || arg-value "$ACBUILD_IMAGE_NAME" || arg-value "$(basename $(pwd))" || necho image
}


# fun: get-version
# txt: 
# env: ACBUILD_IMAGE_VERSION
function get-version() {
	parse-label version || arg-value "${ACBUILD_IMAGE_VERSION:-}" || cat VERSION 2> /dev/null || necho snapshot
}


# env: ACBUILD_IMAGE_OS
function get-os() {
	parse-label os || arg-value "${ACBUILD_IMAGE_OS:-}" || uname | tr '[:upper:]' '[:lower:]' || necho unknown
}


# env: ACBUILD_IMAGE_ARCH
function get-arch() {
	parse-label arch \
			|| arg-value "${ACBUILD_IMAGE_ARCH:-}" \
			|| uname -m | sed -e "s/^\(x64\|x86_64\)$/amd64/g" | tr "[:upper:]" "[:lower:]" \
			|| -n echo unknown
}


# env: ACBUILD_IMAGE_EXT
function get-ext() {
	arg-value "${ACBUILD_IMAGE_EXT:-}" || mode-to-ext "${mode:-}" || necho 'aci'
}

function get-insecure() {
	arg-value "${ACBUILD_RUN_INSECURE:-}" || necho 'false'
}

function get-engine() {
	arg-value "${ACBUILD_RUN_ENGINE:-}" || necho 'systemd-nspawn'
}

# fun: echo '/.-' | sanitize
# txt: replace /._ with underscore
function sanitize() {
	local value
	read -d '' value
	value=${value//-/_}
	value=${value//\//_}
	value=${value//./_}
	echo "$value"
}

# env: name:
#      version:
#      os:
#      arch:
#      ext:
function get-base-name() {
	arg-value "${ACBUILD_IMAGE_BASE_NAME:-}" \
			|| necho "$(necho $name | sanitize)-$version-$os-$arch.$ext"
}



# fun: cat <TEMPLATE> | apply-template
# env: dir_name
#      mode:
#      name:
#      version:
#      os:
#      arch:
#      ext:
#      base_name:
#      output: 
function apply-template() {
	local value
	read -d '' value
	value=${value//\{\{dir-name\}\}/$dir_name}
	value=${value//\{\{mode\}\}/$mode}
	value=${value//\{\{name\}\}/$name}
	value=${value//\{\{version\}\}/$version}
	value=${value//\{\{os\}\}/$os}
	value=${value//\{\{arch\}\}/$arch}
	value=${value//\{\{ext\}\}/$ext}
	value=${value//\{\{base-name\}\}/$base_name}
	value=${value//\{\{insecure\}\}/$insecure}
	value=${value//\{\{engine\}\}/$engine}
	value=${value//\{\{output\}\}/$output}
	echo "$value"
}


# fun: get-output
# env: dir_name
#      name:
#      version:
#      os:
#      arch:
#      ext:
#      base_name:
function get-output() {
	parse-output \
			|| necho "${1:-}"             | stream-value | output="${output:-$dir_name/$base_name}" apply-template | stream-value \
			|| necho "${ACBUILD_IMAGE:-}" | stream-value | output="${output:-$dir_name/$base_name}" apply-template | stream-value \
			|| necho "$dir_name/$base_name"
}




# fun: cat script-template | process-script
# txt: prints resulting script to stdout
function process-template {
	data=$(stream-value) || return $?

	cache_dir=$(get-cache-dir)
	local dir_name=$(                get-dir-name)
	local mode=$(     echo "$data" | get-mode)
	local name=$(     echo "$data" | get-name)
	local version=$(  echo "$data" | get-version)
	local os=$(       echo "$data" | get-os)
	local arch=$(     echo "$data" | get-arch)
	local ext=$(      echo "$data" | get-ext)
	local base_name=$(               get-base-name)
	local insecure=$(                get-insecure)
	local engine=$(                  get-engine)
	local output=$(   echo "$data" | get-output "${2:-}")

	# resolve placeholders inside variables
	# due to transitive dependencies up to 8 iteration needed, usually none
	for i in 1 2 3 4 5 6 7 8 9; do
		if [[ "$dir_name$mode$name$version$os$arch$ext$base_name$output" != *"{{"* ]]; then
			break
		elif [[ $i == 9 ]]; then
			errcho "unable to resolve placeholders, values are:
    dir_name:  $dir_name
    mode:      $mode
    name:      $name
    version:   $version
    os:        $os
    arch:      $arch
    ext:       $ext
    base_name: $base_name
    output:    $output"
			return 1
		fi

		dir_name=$(  echo "$dir_name"  | apply-template)
		mode=$(      echo "$mode"      | apply-template)
		name=$(      echo "$name"      | apply-template)
		version=$(   echo "$version"   | apply-template)
		os=$(        echo "$os"        | apply-template)
		arch=$(      echo "$arch"      | apply-template)
		ext=$(       echo "$ext"       | apply-template)
		base_name=$( echo "$base_name" | apply-template)
		output=$(    echo "$output"    | apply-template)
	done

	echo -n "$data" | apply-template
}


get-file-content() {
	if [[ -z "${1:-}" ]]; then
		errcho "input file name not defined"
		return 1
	fi
	local file_name="$1"
	local error_message="${2:-}"
	if   [[ _- == "_$file_name" ]]; then
		recho
	elif [[ -f "$file_name" ]]; then
		cat "$file_name"
	else
		errcho "${error_message:-input file '$file_name' not found}"
		return 1
	fi
}

put-file-content() {
	if [[ -z "${1:-}" ]]; then
		errcho "output file name not defined"
		return 1
	fi
	local file_name="$1"
	local error_message="${2:-}"
	if   [[ _- == "_$file_name" ]]; then
		recho
	else
		mkdir -p "$(dirname '$file_name')" || true
		recho > "$file_name" || errxit "${error_message:-output file '$file_name' not found}"
	fi
}

# fun: wrap-silent command <handler>
# txt: evaluates commnd, in case of success pipes stdout to handler and outputs result
#      in case of error, print diagnosting information to stderr
wrap-silent() {
	local producer="$1"
	local handler="${2:-}"
	local data=
	if data="$(eval $producer)" ; then
		if [[ _- == "_$handler" ]]; then
			necho "$data"
		elif [[ -n "$handler" ]]; then
			#errcho "handler is $handler"
			#echo hello | eval recho
			necho "$data" | eval "$handler" || return $?
		fi
	else
		local code=$?
		errcho "error running command: $producer"
		errcho "return code: $code"
		[[ -n "$data" ]] && errcho "standard output: $data"
		return $code
	fi
}



# fun: add-argument <append> [<check1> [<check2> ...]]
add-argument() {
	local _value="$(recho)"
	necho "$_value"
	local _append="$1"
	while [[ -n "${1:-}" ]]; do
		if [[ " $_value " == *"$1"* ]]; then
			errcho heeeeeeeere
			return
		fi
		shift
	done
	necho " $_append"
}

# fun: apply [-o|--output <destination>]
# txt: lazily apply 
# env: script:  script file name to process
#      applied: global variable to write applied script data
function apply() {
	local _output=-
	while [[ -n "${1:-}" ]]; do
		if   [[ _-o == "_${1:-}" ]] || [[ _--output == "_${1:-}" ]]; then
			[[ -n "${2:-}" ]] || errxit "missing value for $1"
			_output="$2"
			shift 2
		else
			break
		fi
	done
	if [[ -z "$applied" ]]; then
		applied=$(get-file-content "$script" | process-template) || return $?
	fi
	echo "$applied" | put-file-content "$_output" || return $?
	forward "$@" || return $?
}



# fun: build [-o|--output <output>] [-s|--silent|-n|--print-name]
# txt: lazily build image from script to output
# env: output: global variable to save written image file name
#      cache_dir: 
#      applied:
#      script:
function build() {
	local _output=
	local _handler=-
	#	local _handler='echo $(recho)'
	while [[ -n "${1:-}" ]]; do
		if   [[ _-o == "_$1" ]] || [[ _--output == "_$1" ]]; then
			[[ -n "${2:-}" ]] || errxit "missing value for $1"
			_output="$2"
			shift 2
		elif [[ _-s == "_$1" ]] || [[ _--silent == "_$1" ]]; then
			_handler=
			shift
		elif [[ _-n == "_$1" ]] || [[ _--print-name == "_$1" ]]; then
			_handler='echo $_output'
			shift
		else
			break
		fi
	done

	if [[ -z "$output" ]]; then
		# do the work
		cache_dir=$(get-cache-dir)
		local script_data=$(apply) || return $?
		_output=$(echo "$script_data" | parse-output)
		#errcho "script_data is $script_data"
		[[ -z "$_output" ]] && errxit 'wrong script output'

		mkdir -p "$(dirname '$_output')" "$cache_dir"
		echo "$script_data" > "$cache_dir/acbuild-script"

		local _opts=$(add-argument "--work-path '$cache_dir'" --work-path <<< "${ACBUILD_OPTS:-}")
		rm -rf "$cache_dir/.acbuild"
		wrap-silent "'${ACBUILD:=acbuild}' $_opts script $cache_dir/acbuild-script" "$_handler" || return $?
		output="$_output"
	elif [[ -n "${_handler:-}" ]]; then
		echo "$output"
	fi
	forward "$@" || return $?
}



# fun: sign [-o|--output <output>] [-s|--silent|-n|--print-name-only] [-p|--keyring <keyring> -k|--secret-keyring <secret keyring>]
# env: output: global image output file
sign() {
	local _output=
	local _handler=-
	local _keyring=
	local _secret_keyring=~/.gnupg/secring.gpg
	local _default_arg=
	while [[ -n "${1:-}" ]]; do
		if   [[ _-o == "_$1" ]] || [[ _--output == "_$1" ]]; then
			[[ -n "${2:-}" ]] || errxit "missing value for $1"
			_output="$2"
			shift 2
		elif [[ _-s == "_$1" ]] || [[ _--silent == "_$1" ]]; then
			_handler=
			shift
		elif [[ _-n == "_$1" ]] || [[ _--print-name == "_$1" ]]; then
			_handler='echo $_output'
			shift
		elif   [[ _-p == "_$1" ]] || [[ _--keyring == "_$1" ]]; then
			[[ -n "${2:-}" ]] || errxit "missing value for $1"
			_keyring="$2"
			_default_arg=--no-default-keyring
			shift 2
		elif   [[ _-k == "_$1" ]] || [[ _--secret-keyring == "_$1" ]]; then
			[[ -n "${2:-}" ]] || errxit "missing value for $1"
			_secret_keyring="$2"
			_default_arg=--no-default-keyring
			shift 2
		else
			break
		fi
	done

	if [[ -z "$sign_output" ]]; then
		build --silent || return $?
		[[ -z "$_output" ]] && _output="$output.asc"
		
		local _opts=$(add-argument --armor -a <<< "${GPG_OPTS:-}")
		[[ -z "$_keyring" ]]        && _opts=$(add-argument --no-default-keyring <<< "$_opts")
		[[ -n "$_keyring" ]]        && _opts=$(add-argument "--keyring '$_keyring'" --keyring <<< "$_opts")
		[[ -n "$_secret_keyring" ]] && _opts=$(add-argument "--secret-keyring '$_secret_keyring'" --secret-keyring <<< "$_opts")
		_opts=$(necho "$_opts" | add-argument "--output '$_output'" --output | add-argument "--detach-sig '$output'" --detach-sig)

 		local command="${GPG:-gpg} $_opts"
		wrap-silent "$command" "$_handler" || return $?
		sign_output="$_output"
				
	elif [[ true != "$silent" ]]; then
		echo "$sign_output"
	fi
	forward "$@" || return $?
}


# fun: install [-s|--silent|-n|--print-hash]
# env: cache_dir
#      script
#      applied
#      output
#      sign_output
#      image_hash: global installed image hash
function install() {
	local _output=
	local _handler=-
	#	local _handler='echo $(recho)'
	while [[ -n "${1:-}" ]]; do
		if [[ _-s == "_$1" ]] || [[ _--silent == "_$1" ]]; then
			_handler=
			shift
		elif [[ _-n == "_$1" ]] || [[ _--print-hash == "_$1" ]]; then
			_handler='echo $image_hash'
			shift
		else
			break
		fi
	done

	if [[ -z "$image_hash" ]]; then
		build --silent || return $?
		local _opts=$(echo "${RKT_FETCH_OPTS:=}" | add-argument --full)
		real_output=$(realpath "$output")

		local _command="'${RKT:-rkt}' ${RKT_OPTS:-} fetch $_opts 'file://$real_output'"
		if [[ -n "$sign_output" ]]; then
			_command="$_command --signature '$sign_output'"
		fi

		local _data
		_data=$(eval $_command) || return $?
		image_hash=$(necho "$_data" | last-line)
		wrap-silent "necho '$_data'" "$_handler" || return $?
	elif [[ true != "$silent" ]]; then
		echo "$image_hash"
	fi
	forward "$@" || return $?
}


# env: cache_dir
#      script
#      applied
#      output
#      sign_output
#      image_hash
function run() {
	install --silent || return $?
	exec "${RKT:-rkt}" ${RKT_OPTS:-} run "$image_hash" ${RKT_RUN_OPTS:-} "$@"
}

function upload-git() {
	echo
}


# fun: [script=<script>] forward [-o|--output <output>]
# txt: 
# env: cache_dir
#      script
#      applied
#      output
#      sign_output
#      image_hash      
forward() {
	if   [[ -z "${1:-}" ]]; then
		return
	elif [[ apply   == "$1" ]]; then
		shift
		apply "$@" || return $?
	elif [[ build   == "$1" ]]; then
		shift
		build "$@" || return $?
	elif [[ sign    == "$1" ]]; then
		shift
		sign "$@" || return $?
	elif [[ install == "$1" ]]; then
		shift 
		install "$@" || return $?
	elif [[ upload-git == "$1" ]]; then
		shift
		upload "$@" || return $?
	elif [[ run     == "$1" ]]; then
		shift
		run "$@" || return $?
	else
		errxit "unexpected argument $1"
	fi
}

function main() {
	if [[ -z "${1:-}" ]]; then
		errcho 'at least one command expected'
		print-usage
		return 1
	fi

	# "global" variables
	# 
	local cache_dir=

	# script template to process, set once at startup
	local script=$(get-script)

	# cache to store applied script text beween apply-calls
	local applied=

	# cache to store written image file name between build-calls
	local output=
	local sign_output=
	local image_hash=

	# parse common arguments
	while [[ -n "${1:-}" ]]; do
		if   [[ _-i == "_$1" ]] || [[ _--script == "_$1" ]]; then
			[[ -n "${2:-}" ]] || errxit "missing value for $1"
			script="$2"
			shift 2
		else
			break;
		fi
	done

	# execute commands
	forward "$@" || return $?
}



# todo better condition wanted
if [[ "$0" == "$BASH_SOURCE" ]]; then
	main "$@" || exit $?
fi

